<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Textify">
    <title>Textify</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=DM+Sans:opsz,wght@9..40,300;9..40,400;9..40,500;9..40,600&display=swap" rel="stylesheet">
    <style>
        :root {--bg:#0a0a0a;--surface:#141414;--surface-hover:#1a1a1a;--border:#2a2a2a;--text:#fafafa;--text-muted:#888;--text-dim:#555;--accent:#e8ff47;--accent-dim:#b8cc39;--accent-bg:rgba(232,255,71,0.1);--success:#4ade80;--error:#f87171;--warning:#fbbf24;--serif:'Instrument Serif',Georgia,serif;--sans:'DM Sans',system-ui,sans-serif;--radius:12px;--radius-sm:8px}
        *{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
        html,body{font-family:var(--sans);background:var(--bg);color:var(--text);min-height:100vh;line-height:1.6;overflow-x:hidden}
        .app{display:flex;flex-direction:column;min-height:100vh}
        .header{padding:20px 24px;display:flex;align-items:center;justify-content:space-between;border-bottom:1px solid var(--border);position:sticky;top:0;background:var(--bg);z-index:100}
        .logo{font-family:var(--serif);font-size:1.75rem;font-style:italic}.logo span{color:var(--accent)}
        .header-actions{display:flex;align-items:center;gap:12px}
        .sync-status{display:flex;align-items:center;gap:6px;font-size:0.8rem;color:var(--text-muted)}
        .sync-dot{width:8px;height:8px;border-radius:50%;background:var(--text-dim)}
        .sync-dot.syncing{background:var(--warning);animation:pulse 1s infinite}
        .sync-dot.synced{background:var(--success)}.sync-dot.error{background:var(--error)}
        @keyframes pulse{0%,100%{opacity:1}50%{opacity:0.5}}
        .icon-btn{width:40px;height:40px;border-radius:var(--radius-sm);border:1px solid var(--border);background:var(--surface);color:var(--text);display:flex;align-items:center;justify-content:center;cursor:pointer}
        .icon-btn.spinning svg{animation:spin 1s linear infinite}
        @keyframes spin{to{transform:rotate(360deg)}}
        .icon-btn svg{width:20px;height:20px}
        .main{flex:1;display:flex;flex-direction:column;overflow:hidden}
        .auth-screen{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:40px 24px;text-align:center; z-index: 50;}
        .auth-screen.hidden{display:none}
        .auth-icon{width:80px;height:80px;margin-bottom:24px;color:var(--accent)}
        .auth-title{font-family:var(--serif);font-size:1.75rem;font-style:italic;margin-bottom:12px}
        .auth-desc{color:var(--text-muted);font-size:0.95rem;max-width:320px;margin-bottom:32px}
        .auth-btn{display:flex;align-items:center;gap:12px;padding:16px 32px;background:var(--text);color:var(--bg);border:none;border-radius:var(--radius);font-family:var(--sans);font-size:1rem;font-weight:500;cursor:pointer; opacity: 1; transition: opacity 0.3s;}
        .auth-btn:disabled{opacity: 0.5; cursor: not-allowed;}
        .auth-btn svg{width:24px;height:24px}
        .content{flex:1;display:none;flex-direction:column;overflow:hidden}
        .content.visible{display:flex}
        .playlist-container{flex:1;overflow-y:auto;padding:20px 24px;padding-bottom:220px}
        .playlist-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:20px}
        .playlist-title{font-family:var(--serif);font-size:1.25rem;font-style:italic}
        .playlist-count{font-size:0.85rem;color:var(--text-muted)}
        .playlist-empty{text-align:center;padding:60px 20px;color:var(--text-muted)}
        .playlist{display:flex;flex-direction:column;gap:8px}
        .track{display:flex;align-items:center;gap:16px;padding:16px;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);cursor:pointer}
        .track:hover{background:var(--surface-hover)}
        .track.active{background:var(--accent-bg);border-color:var(--accent)}
        .track.generating{opacity:0.7}
        .track-number{width:32px;height:32px;display:flex;align-items:center;justify-content:center;font-size:0.85rem;color:var(--text-muted);flex-shrink:0}
        .track.active .track-number{color:var(--accent)}
        .track-equalizer{display:none;gap:2px;align-items:flex-end;height:16px}
        .track.active.playing .track-number span{display:none}
        .track.active.playing .track-equalizer{display:flex}
        .eq-bar{width:3px;background:var(--accent);border-radius:1px;animation:eq 0.8s ease-in-out infinite}
        .eq-bar:nth-child(1){height:60%;animation-delay:0s}
        .eq-bar:nth-child(2){height:100%;animation-delay:0.2s}
        .eq-bar:nth-child(3){height:40%;animation-delay:0.4s}
        @keyframes eq{0%,100%{transform:scaleY(1)}50%{transform:scaleY(0.5)}}
        .track-info{flex:1;min-width:0}
        .track-title{font-weight:500;font-size:0.95rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;margin-bottom:4px}
        .track-meta{display:flex;align-items:center;gap:12px;font-size:0.8rem;color:var(--text-muted)}
        .track-folder{display:flex;align-items:center;gap:4px}
        .track-folder svg{width:14px;height:14px}
        .status-badge{padding:4px 8px;border-radius:4px;font-size:0.7rem;font-weight:500;text-transform:uppercase}
        .status-badge.cached{background:rgba(74,222,128,0.15);color:var(--success)}
        .status-badge.generating{background:rgba(251,191,36,0.15);color:var(--warning)}
        .status-badge.new{background:rgba(232,255,71,0.15);color:var(--accent)}
        .status-badge.pending{background:rgba(136,136,136,0.15);color:var(--text-muted)}
        .track-delete-btn{width:40px;height:40px;border-radius:50%;border:none;background:rgba(248,113,113,0.15);color:var(--error);display:flex;align-items:center;justify-content:center;cursor:pointer;flex-shrink:0}
        .track-delete-btn svg{width:18px;height:18px}
        .player{position:fixed;bottom:0;left:0;right:0;background:linear-gradient(to top,var(--bg) 80%,transparent);padding:20px 24px 32px;padding-bottom:max(32px,env(safe-area-inset-bottom)); z-index: 200;}
        .player.hidden{display:none}
        .player-card{background:var(--surface);border:1px solid var(--border);border-radius:16px;padding:20px;box-shadow:0 -8px 32px rgba(0,0,0,0.4)}
        .player-track-info{display:flex;align-items:center;gap:12px;margin-bottom:16px}
        .player-track-title{flex:1;font-weight:500;font-size:0.95rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
        .player-track-position{font-size:0.8rem;color:var(--text-muted)}
        .player-progress{margin-bottom:16px}
        .progress-bar{width:100%;height:6px;background:var(--border);border-radius:3px;overflow:hidden;cursor:pointer}
        .progress-fill{height:100%;background:var(--accent);border-radius:3px;width:0%}
        .progress-times{display:flex;justify-content:space-between;margin-top:8px;font-size:0.75rem;color:var(--text-muted)}
        .player-controls{display:flex;align-items:center;justify-content:center;gap:12px}
        .control-btn{width:48px;height:48px;border-radius:50%;border:none;background:transparent;color:var(--text);display:flex;align-items:center;justify-content:center;cursor:pointer}
        .control-btn svg{width:24px;height:24px}
        .control-btn.play-pause{width:64px;height:64px;background:var(--accent);color:var(--bg)}
        .control-btn.play-pause svg{width:28px;height:28px}
        .speed-btn{min-width:48px;padding:8px 12px;border-radius:20px;border:1px solid var(--border);background:var(--surface);color:var(--text);font-family:var(--sans);font-size:0.8rem;font-weight:500;cursor:pointer}
        .toast{position:fixed;top:24px;left:50%;transform:translateX(-50%) translateY(-100px);padding:14px 24px;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);color:var(--text);font-size:0.9rem;opacity:0;transition:all 0.3s;z-index:300}
        .toast.show{transform:translateX(-50%) translateY(0);opacity:1}
        .toast.error{border-color:var(--error)}.toast.success{border-color:var(--success)}

        /* Settings Modal */
        .modal-overlay {position: fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:900; display:none; align-items:center; justify-content:center;}
        .modal-overlay.visible {display:flex;}
        .modal {background:var(--bg); border:1px solid var(--border); width: 90%; max-width: 500px; max-height: 80vh; border-radius: var(--radius); display: flex; flex-direction: column; overflow: hidden;}
        .modal-header {padding: 16px 20px; border-bottom: 1px solid var(--border); display:flex; justify-content:space-between; align-items:center;}
        .modal-title {font-family: var(--serif); font-size: 1.25rem;}
        .modal-close {background:none; border:none; color:var(--text-muted); cursor:pointer;}
        .modal-content {padding: 0; overflow-y: auto; flex: 1;}
        
        .settings-section-title {padding: 16px 20px 8px; font-size: 0.85rem; text-transform: uppercase; color: var(--text-muted); letter-spacing: 0.05em; font-weight: 600;}
        .settings-actions {padding: 0 20px 20px;}
        .settings-info {padding: 0 20px 10px; font-size: 0.8rem; color: var(--text-dim); line-height: 1.4;}
        
        .voice-list {display:flex; flex-direction: column;}
        .voice-item {padding: 12px 20px; border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 12px; cursor: pointer;}
        .voice-item:hover {background: var(--surface-hover);}
        .voice-item.selected {background: var(--accent-bg);}
        .voice-item.selected .voice-name {color: var(--accent);}
        .voice-radio {accent-color: var(--accent);}
        .voice-details {flex:1;}
        .voice-name {font-weight: 500; font-size: 0.95rem;}
        .voice-tag {font-size: 0.75rem; color: var(--text-muted);}
        .voice-preview-btn {width: 32px; height: 32px; border-radius: 50%; border: 1px solid var(--border); background: var(--surface); color: var(--text); display: flex; align-items: center; justify-content: center; cursor: pointer;}
        .voice-preview-btn:hover {background: var(--text); color: var(--bg);}

        .danger-btn {width: 100%; padding: 12px; border-radius: var(--radius); border: 1px solid var(--error); background: rgba(248,113,113,0.1); color: var(--error); font-weight: 500; font-family: var(--sans); cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; transition: all 0.2s;}
        .danger-btn:hover {background: var(--error); color: var(--bg);}
        .danger-btn svg {width: 18px; height: 18px;}
    </style>
</head>
<body>
    <div class="app">
        <header class="header">
            <h1 class="logo">Textify<span>.</span></h1>
            <div class="header-actions">
                <div class="sync-status"><div class="sync-dot" id="sync-dot"></div><span id="sync-text">Offline</span></div>
                <button class="icon-btn" id="settings-btn" title="Settings"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-2 2 2 2 0 01-2-2v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0 2 2 0 010-2.83l.06-.06a1.65 1.65 0 00.33-1.82 1.65 1.65 0 00-1.51-1H3a2 2 0 01-2-2 2 2 0 012-2h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 010-2.83 2 2 0 012.83 0l.06.06a1.65 1.65 0 001.82.33H9a1.65 1.65 0 001-1.51V3a2 2 0 012-2 2 2 0 012 2v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0 2 2 0 010 2.83l-.06.06a1.65 1.65 0 00-.33 1.82V9a1.65 1.65 0 001.51 1H21a2 2 0 012 2 2 2 0 01-2 2h-.09a1.65 1.65 0 00-1.51 1z"/></svg></button>
                <button class="icon-btn" id="refresh-btn" title="Sync"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M23 4v6h-6M1 20v-6h6"/><path d="M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15"/></svg></button>
            </div>
        </header>
        <main class="main">
            <div class="auth-screen" id="auth-screen">
                <svg class="auth-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><path d="M14 2v6h6M16 13H8M16 17H8M10 9H8"/></svg>
                <h2 class="auth-title">Connect Google Drive</h2>
                <p class="auth-desc">Sign in to sync your documents and listen to them with Google Neural2 Voices.</p>
                <button class="auth-btn" id="auth-btn" disabled>
                    <svg viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>
                    <span>Loading...</span>
                </button>
            </div>
            <div class="content" id="content">
                <div class="playlist-container">
                    <div class="playlist-header"><h2 class="playlist-title">Your Documents</h2><span class="playlist-count" id="playlist-count">0 documents</span></div>
                    <div class="playlist-empty" id="playlist-empty"><p>No documents found. Click sync to check your folders.</p></div>
                    <div class="playlist" id="playlist"></div>
                </div>
            </div>
        </main>
        <div class="player hidden" id="player">
            <div class="player-card">
                <div class="player-track-info"><span class="player-track-title" id="player-title">No track selected</span><span class="player-track-position" id="player-position">0 / 0</span></div>
                <div class="player-progress"><div class="progress-bar" id="progress-bar"><div class="progress-fill" id="progress-fill"></div></div><div class="progress-times"><span id="current-time">0:00</span><span id="total-time">0:00</span></div></div>
                <div class="player-controls">
                    <button class="control-btn" id="prev-btn"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/></svg></button>
                    <button class="control-btn" id="rewind-btn"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 4v6h6"/><path d="M3.51 15a9 9 0 102.13-9.36L1 10"/></svg></button>
                    <button class="control-btn play-pause" id="play-pause-btn"><svg viewBox="0 0 24 24" fill="currentColor" id="play-icon"><path d="M8 5v14l11-7z"/></svg><svg viewBox="0 0 24 24" fill="currentColor" id="pause-icon" style="display:none"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg></button>
                    <button class="control-btn" id="forward-btn"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M23 4v6h-6"/><path d="M20.49 15a9 9 0 11-2.12-9.36L23 10"/></svg></button>
                    <button class="control-btn" id="next-btn"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg></button>
                    <button class="speed-btn" id="speed-btn">1.25x</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="settings-modal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Settings</h3>
                <button class="modal-close" id="close-settings"><svg viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"/></svg></button>
            </div>
            <div class="modal-content">
                <h4 class="settings-section-title">Voice</h4>
                <div class="voice-list" id="voice-list">
                    </div>
                
                <h4 class="settings-section-title">Storage</h4>
                <div class="settings-info">Clearing documents sets the sync time to "now", ignoring older files.</div>
                <div class="settings-actions">
                    <button id="clear-all-btn" class="danger-btn">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        Clear All Documents
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <script>
    // Config
    var CLIENT_ID = '959875839996-h7cogpr60gugmqco9f9i5ehkjr0hq569.apps.googleusercontent.com';
    var API_KEY = 'AIzaSyCQ1_Y6-w_lOzjRUMN2lxRFuZfT4y-9ICg'; // WORKING KEY
    var ALLOWED_USER = 'briandigate';
    var FOLDER_IDS = ['1YEj74qrmNYMZcQ90l_6wlq6c6DDk4YbR','1kc57wQ2rCLI4yKOK7h2pbhS1XMUFGs9y','1kedNH3hNJUh6frA1iN2xoXc5g--FNvZs'];
    var SCOPES = 'https://www.googleapis.com/auth/drive.readonly https://www.googleapis.com/auth/userinfo.email';

    // State
    var tokenClient, gapiInited = false, gisInited = false, accessToken = null;
    var playlist = [], currentTrackIndex = -1, isPlaying = false;
    var playbackSpeed = 1.25, speeds = [0.75, 1, 1.25, 1.5, 1.75, 2];
    var db, deletedIds = new Set();
    var audio = new Audio(); // HTML5 Audio for Google Cloud TTS
    var selectedVoiceId = localStorage.getItem('selectedVoice') || 'en-US-Neural2-J';
    var textChunks = []; 
    var currentChunkIdx = 0;
    var lastSyncTime = localStorage.getItem('lastSyncTime');

    // Hardcoded Full Fallback Voices (No B)
    const BACKUP_VOICES = [
        { name: 'en-US-Neural2-A', ssmlGender: 'MALE' },
        { name: 'en-US-Neural2-C', ssmlGender: 'FEMALE' },
        { name: 'en-US-Neural2-D', ssmlGender: 'MALE' },
        { name: 'en-US-Neural2-E', ssmlGender: 'FEMALE' },
        { name: 'en-US-Neural2-F', ssmlGender: 'FEMALE' },
        { name: 'en-US-Neural2-G', ssmlGender: 'FEMALE' },
        { name: 'en-US-Neural2-H', ssmlGender: 'FEMALE' },
        { name: 'en-US-Neural2-I', ssmlGender: 'MALE' },
        { name: 'en-US-Neural2-J', ssmlGender: 'MALE' }
    ];

    // DOM
    var authScreen = document.getElementById('auth-screen');
    var authBtn = document.getElementById('auth-btn');
    var content = document.getElementById('content');
    var syncDot = document.getElementById('sync-dot');
    var syncText = document.getElementById('sync-text');
    var refreshBtn = document.getElementById('refresh-btn');
    var settingsBtn = document.getElementById('settings-btn');
    var settingsModal = document.getElementById('settings-modal');
    var closeSettingsBtn = document.getElementById('close-settings');
    var voiceListEl = document.getElementById('voice-list');
    var clearAllBtn = document.getElementById('clear-all-btn');
    var playlistEl = document.getElementById('playlist');
    var playlistEmpty = document.getElementById('playlist-empty');
    var playlistCount = document.getElementById('playlist-count');
    var player = document.getElementById('player');
    var playerTitle = document.getElementById('player-title');
    var playerPosition = document.getElementById('player-position');
    var progressFill = document.getElementById('progress-fill');
    var currentTimeEl = document.getElementById('current-time');
    var totalTimeEl = document.getElementById('total-time');
    var playPauseBtn = document.getElementById('play-pause-btn');
    var playIcon = document.getElementById('play-icon');
    var pauseIcon = document.getElementById('pause-icon');
    var speedBtn = document.getElementById('speed-btn');
    var toast = document.getElementById('toast');

    // Init
    function init() {
        initDB().then(function() {
            loadDeletedIds();
            loadCachedPlaylist();
            initGoogleAPI();
            setupEvents();
            fetchVoices(); 
        });
    }

    // IndexedDB
    function initDB() {
        return new Promise(function(resolve) {
            var req = indexedDB.open('TextifyDB', 1);
            req.onupgradeneeded = function(e) { e.target.result.createObjectStore('docs', {keyPath: 'id'}); };
            req.onsuccess = function(e) { db = e.target.result; resolve(); };
            req.onerror = function() { resolve(); };
        });
    }

    function saveDoc(id, text, meta) {
        var tx = db.transaction('docs', 'readwrite');
        tx.objectStore('docs').put({id: id, text: text, meta: meta});
    }

    function getAllDocs(callback) {
        var tx = db.transaction('docs', 'readonly');
        var req = tx.objectStore('docs').getAll();
        req.onsuccess = function() { callback(req.result || []); };
    }

    function deleteDoc(id) {
        var tx = db.transaction('docs', 'readwrite');
        tx.objectStore('docs').delete(id);
    }

    function loadDeletedIds() {
        var s = localStorage.getItem('deleted');
        if (s) deletedIds = new Set(JSON.parse(s));
    }

    function saveDeletedIds() {
        localStorage.setItem('deleted', JSON.stringify(Array.from(deletedIds)));
    }

    // Google Auth - ROBUST VERSION
    function initGoogleAPI() {
        gapi.load('client', function() {
            gapi.client.init({
                apiKey: API_KEY,
                discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest']
            }).then(function() {
                gapiInited = true;
                checkInitState();
            }).catch(function(err) {
                console.error("GAPI Init Error:", err);
                authBtn.querySelector('span').textContent = 'API Error (Check Console)';
                showToast("Google API Error: " + (err.error?.message || "Unknown"), 'error');
            });
        });
        tokenClient = google.accounts.oauth2.initTokenClient({
            client_id: CLIENT_ID,
            scope: SCOPES,
            callback: onAuthResponse
        });
        gisInited = true;
        checkInitState();
    }

    function checkInitState() {
        if (gapiInited && gisInited) {
            authBtn.disabled = false;
            authBtn.querySelector('span').textContent = 'Sign in with Google';
            checkStoredToken();
        }
    }

    function checkStoredToken() {
        var token = localStorage.getItem('token');
        if (token && gapiInited) {
            accessToken = token;
            gapi.client.setToken({access_token: token});
            verifyUser();
        }
    }

    function verifyUser() {
        fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
            headers: {'Authorization': 'Bearer ' + accessToken}
        }).then(function(r) { 
            if (r.status === 401) {
                signOut(); // Explicitly reset UI
                showToast('Session expired. Please sign in again.', 'info');
                return null; 
            }
            return r.json(); 
        }).then(function(user) {
            if (!user) return; 
            if (user.email && user.email.split('@')[0].toLowerCase() === ALLOWED_USER) {
                showContent();
                syncDrive();
            } else {
                showToast('Access denied', 'error');
                signOut();
            }
        }).catch(function() {
            localStorage.removeItem('token');
            accessToken = null;
        });
    }

    function onAuthResponse(resp) {
        if (resp.error) { showToast('Auth failed', 'error'); return; }
        accessToken = resp.access_token;
        localStorage.setItem('token', accessToken);
        verifyUser();
    }

    function signIn() {
        if (gapiInited && gisInited) {
            tokenClient.requestAccessToken({}); 
        }
    }

    function signOut() {
        if (accessToken) google.accounts.oauth2.revoke(accessToken);
        accessToken = null;
        localStorage.removeItem('token');
        authScreen.classList.remove('hidden');
        content.classList.remove('visible');
        player.classList.add('hidden'); // Ensure player hides
        syncDot.className = 'sync-dot';
        syncText.textContent = 'Offline';
    }

    function showContent() {
        authScreen.classList.add('hidden');
        content.classList.add('visible');
        renderPlaylist(); // Re-check visibility
    }

    // Sync
    function syncDrive() {
        syncDot.className = 'sync-dot syncing';
        syncText.textContent = 'Scanning...';
        refreshBtn.classList.add('spinning');

        var files = [];
        var foldersDone = 0;
        
        // API Level Filter
        var query = "trashed=false and mimeType='application/vnd.google-apps.document'";
        if (lastSyncTime) {
            query += " and createdTime > '" + lastSyncTime + "'";
        }

        FOLDER_IDS.forEach(function(folderId) {
            gapi.client.drive.files.get({fileId: folderId, fields: 'name'}).then(function(folderResp) {
                var folderName = folderResp.result.name;
                gapi.client.drive.files.list({
                    q: "'" + folderId + "' in parents and " + query,
                    fields: 'files(id,name,modifiedTime,createdTime)', 
                    orderBy: 'createdTime desc', 
                    pageSize: 100
                }).then(function(resp) {
                    (resp.result.files || []).forEach(function(f) {
                        // CLIENT SIDE HARD FILTER - Double check
                        if (lastSyncTime && f.createdTime < lastSyncTime) {
                            return; // Skip old files
                        }
                        if (!deletedIds.has(f.id)) {
                            files.push({id: f.id, name: f.name, folder: folderName, modified: f.modifiedTime, created: f.createdTime});
                        }
                    });
                    foldersDone++;
                    if (foldersDone === FOLDER_IDS.length) finishSync(files);
                });
            }).catch(function() {
                foldersDone++;
                if (foldersDone === FOLDER_IDS.length) finishSync(files);
            });
        });
    }

    function finishSync(newFiles) {
        // Sort Newest First
        newFiles.sort(function(a, b) {
            return new Date(b.created) - new Date(a.created);
        });

        getAllDocs(function(cached) {
            var cacheMap = {};
            cached.forEach(function(c) { cacheMap[c.id] = c; });

            // Merge: Keep existing playlist items, prepend NEW items
            var existingIds = new Set(playlist.map(function(p) { return p.id; }));
            var addedCount = 0;

            // Prepend new files to playlist
            for (var i = newFiles.length - 1; i >= 0; i--) {
                var f = newFiles[i];
                if (!existingIds.has(f.id)) {
                    playlist.unshift({
                        id: f.id,
                        name: f.name,
                        folder: f.folder,
                        modified: f.modified,
                        status: 'pending', // Needs download
                        text: null
                    });
                    addedCount++;
                }
            }

            localStorage.setItem('playlist', JSON.stringify(playlist));
            
            // Only update sync time if we actually found something, OR if this was the first run
            if (addedCount > 0 || !lastSyncTime) {
                // Do not update time here, wait for next Clear. 
                // Actually, standard behavior: update time so we don't fetch these again next reload.
                // But we store them in 'playlist' so we won't lose them.
                lastSyncTime = new Date().toISOString();
                localStorage.setItem('lastSyncTime', lastSyncTime);
            }

            renderPlaylist();
            syncDot.className = 'sync-dot synced';
            syncText.textContent = playlist.length + ' docs';
            refreshBtn.classList.remove('spinning');
            
            // Auto-Download ONLY the single newest file if it's new
            if (addedCount > 0 && playlist.length > 0) {
                showToast('Found ' + addedCount + ' new docs', 'success');
                downloadSingleItem(0); // Only download the top one automatically
            } else if (playlist.length === 0) {
                showToast('No new documents found', 'info');
            }
        });
    }

    function downloadSingleItem(i) {
        if (!playlist[i] || playlist[i].status === 'cached') return;

        playlist[i].status = 'generating';
        renderPlaylist();

        gapi.client.drive.files.export({fileId: playlist[i].id, mimeType: 'text/plain'}).then(function(resp) {
            var text = resp.body;
            if (text && text.trim()) {
                saveDoc(playlist[i].id, text, {
                    name: playlist[i].name, 
                    folder: playlist[i].folder,
                    modified: playlist[i].modified 
                });
                playlist[i].text = text;
                playlist[i].status = 'cached';
            } else {
                playlist[i].status = 'pending';
            }
            renderPlaylist();
        }).catch(function() {
            playlist[i].status = 'pending';
            renderPlaylist();
        });
    }

    function loadCachedPlaylist() {
        var saved = localStorage.getItem('playlist');
        if (saved) {
            playlist = JSON.parse(saved);
            playlist = playlist.filter(function(p) { return !deletedIds.has(p.id); });
            getAllDocs(function(cached) {
                var cacheMap = {};
                cached.forEach(function(c) { cacheMap[c.id] = c; });
                playlist.forEach(function(p) {
                    var c = cacheMap[p.id];
                    if (c) { p.text = c.text; p.status = 'cached'; }
                });
                renderPlaylist();
            });
        }
    }

    function clearAllDocuments() {
        if (!confirm('Clear list and ignore all old files? (Only new files created from now on will appear)')) return;
        
        stopAudio();
        playlist = [];
        localStorage.removeItem('playlist');
        
        // Key Fix: Set the time barrier to NOW
        lastSyncTime = new Date().toISOString();
        localStorage.setItem('lastSyncTime', lastSyncTime);
        
        var tx = db.transaction('docs', 'readwrite');
        tx.objectStore('docs').clear();
        
        renderPlaylist();
        showToast('Cleared. Only NEW files will appear now.', 'success');
        settingsModal.classList.remove('visible');
        syncDot.className = 'sync-dot';
        syncText.textContent = 'Offline';
    }

    // Render
    function renderPlaylist() {
        if (playlist.length === 0) {
            playlistEmpty.style.display = 'block';
            playlistEl.innerHTML = '';
            playlistCount.textContent = '0 documents';
            player.classList.add('hidden');
            return;
        }
        playlistEmpty.style.display = 'none';
        playlistCount.textContent = playlist.length + ' doc' + (playlist.length > 1 ? 's' : '');

        var html = '';
        for (var i = 0; i < playlist.length; i++) {
            var p = playlist[i];
            var active = i === currentTrackIndex;
            var playing = active && isPlaying;
            
            var statusLabel = p.status;
            if (p.status === 'pending') statusLabel = 'cloud'; 
            
            html += '<div class="track' + (active ? ' active' : '') + (playing ? ' playing' : '') + '" data-i="' + i + '">';
            html += '<div class="track-number"><span>' + (i+1) + '</span><div class="track-equalizer"><div class="eq-bar"></div><div class="eq-bar"></div><div class="eq-bar"></div></div></div>';
            html += '<div class="track-info"><div class="track-title">' + esc(p.name) + '</div>';
            html += '<div class="track-meta"><span class="track-folder"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>' + esc(p.folder) + '</span>';
            html += '<span class="status-badge ' + p.status + '">' + statusLabel + '</span></div></div>';
            html += '<button class="track-delete-btn" data-i="' + i + '"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg></button>';
            html += '</div>';
        }
        playlistEl.innerHTML = html;

        var tracks = playlistEl.querySelectorAll('.track');
        for (var t = 0; t < tracks.length; t++) {
            tracks[t].onclick = function(e) {
                if (e.target.closest('.track-delete-btn')) return;
                var idx = parseInt(this.getAttribute('data-i'));
                // Click to download & play logic
                if (playlist[idx].status === 'pending') {
                    downloadSingleItem(idx);
                    // Optionally auto-play after download? For now, download first.
                    // To auto-play we'd need to chain the promise.
                    // Ideally, just triggering downloadSingleItem updates status to 'generating', 
                    // then 'cached'. User can click again or we can wait.
                    // Simple UX: Just download.
                } else {
                    play(idx);
                }
            };
        }
        var delBtns = playlistEl.querySelectorAll('.track-delete-btn');
        for (var d = 0; d < delBtns.length; d++) {
            delBtns[d].onclick = function(e) {
                e.stopPropagation();
                deleteTrack(parseInt(this.getAttribute('data-i')));
            };
        }

        // Logic fix: only show player if user is logged in (content visible) AND playlist has items
        if (playlist.length > 0 && content.classList.contains('visible')) {
            player.classList.remove('hidden');
        } else {
            player.classList.add('hidden');
        }
    }

    function deleteTrack(i) {
        var p = playlist[i];
        if (!p) return;
        if (currentTrackIndex === i) { stopAudio(); currentTrackIndex = -1; }
        else if (currentTrackIndex > i) currentTrackIndex--;
        deleteDoc(p.id);
        deletedIds.add(p.id);
        saveDeletedIds();
        playlist.splice(i, 1);
        localStorage.setItem('playlist', JSON.stringify(playlist));
        renderPlaylist();
        showToast('Removed', 'success');
        if (playlist.length === 0) player.classList.add('hidden');
    }

    // --- GOOGLE CLOUD TTS LOGIC ---

    async function fetchVoices() {
        const url = `https://texttospeech.googleapis.com/v1/voices?key=${API_KEY}&languageCode=en-US`;
        try {
            const response = await fetch(url);
            const data = await response.json();
            // Filter for Neural2 voices as requested
            let voices = [];
            if(data.voices){
                voices = data.voices.filter(v => v.name.includes('Neural2'));
            }
            // If empty (permission error or network), use backup
            if(voices.length === 0) voices = BACKUP_VOICES;
            renderVoiceList(voices);
        } catch (e) {
            console.error('Failed to fetch voices, using backup', e);
            renderVoiceList(BACKUP_VOICES); // Fallback so menu isn't empty
        }
    }

    function renderVoiceList(voices) {
        let html = '';
        voices.forEach(v => {
            const isSelected = v.name === selectedVoiceId;
            html += `<div class="voice-item ${isSelected ? 'selected' : ''}" onclick="selectVoice('${v.name}')">
                <input type="radio" name="voice" class="voice-radio" ${isSelected ? 'checked' : ''}>
                <div class="voice-details">
                    <div class="voice-name">${v.name.replace('en-US-Neural2-', 'Neural ')} (${v.ssmlGender})</div>
                    <div class="voice-tag">English (US)</div>
                </div>
                <button class="voice-preview-btn" onclick="previewVoice(event, '${v.name}')" title="Preview">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><path d="M8 5v14l11-7z"/></svg>
                </button>
            </div>`;
        });
        voiceListEl.innerHTML = html;
    }

    function selectVoice(id) {
        selectedVoiceId = id;
        localStorage.setItem('selectedVoice', id);
        document.querySelectorAll('.voice-item').forEach(el => {
            if (el.innerHTML.includes(id)) {
                el.classList.add('selected');
                el.querySelector('input').checked = true;
            } else {
                el.classList.remove('selected');
                el.querySelector('input').checked = false;
            }
        });
    }

    async function previewVoice(e, id) {
        e.stopPropagation(); 
        showToast('Previewing...', 'info');
        const content = await synthesizeText("Hello. This is a preview of my voice.", id);
        if (content) {
            const tempAudio = new Audio("data:audio/mp3;base64," + content);
            tempAudio.play();
        }
    }

    async function synthesizeText(text, voiceId) {
        const url = `https://texttospeech.googleapis.com/v1/text:synthesize?key=${API_KEY}`;
        const payload = {
            input: { text: text },
            voice: { languageCode: 'en-US', name: voiceId },
            audioConfig: { audioEncoding: 'MP3' }
        };

        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const data = await response.json();
            if (data.error) throw new Error(data.error.message);
            return data.audioContent; 
        } catch (e) {
            console.error(e);
            showToast('TTS Error: ' + e.message, 'error');
            return null;
        }
    }

    function chunkText(text) {
        const limit = 4500; 
        const chunks = [];
        let index = 0;
        
        while (index < text.length) {
            let endIndex = Math.min(index + limit, text.length);
            if (endIndex < text.length) {
                const lastPeriod = text.lastIndexOf('.', endIndex);
                const lastSpace = text.lastIndexOf(' ', endIndex);
                if (lastPeriod > index) endIndex = lastPeriod + 1;
                else if (lastSpace > index) endIndex = lastSpace;
            }
            chunks.push(text.substring(index, endIndex));
            index = endIndex;
        }
        return chunks;
    }

    async function play(i) {
        if (i < 0 || i >= playlist.length) return;
        
        if (currentTrackIndex !== i) {
            stopAudio();
            currentTrackIndex = i;
        }

        var p = playlist[i];

        if (!p.text) {
            showToast('Downloading doc...', 'info');
            gapi.client.drive.files.export({fileId: p.id, mimeType: 'text/plain'}).then(function(resp) {
                p.text = resp.body;
                p.status = 'cached';
                saveDoc(p.id, p.text, {name: p.name, folder: p.folder});
                renderPlaylist();
                play(i); 
            }).catch(function() { showToast('Failed to load', 'error'); });
            return;
        }

        if (textChunks.length === 0) {
            textChunks = chunkText(p.text);
            currentChunkIdx = 0;
            playerTitle.textContent = p.name;
            playerPosition.textContent = (i + 1) + ' / ' + playlist.length;
            totalTimeEl.textContent = "~" + Math.ceil(p.text.length / 1000) + " min"; 
        }

        playNextChunk();
    }

    async function playNextChunk() {
        if (currentChunkIdx >= textChunks.length) {
            if (currentTrackIndex < playlist.length - 1) {
                textChunks = []; 
                play(currentTrackIndex + 1);
            } else {
                stopAudio();
                showToast('Playlist finished', 'success');
            }
            return;
        }

        if (currentChunkIdx === 0) showToast('Generating Audio...', 'info');

        const audioContent = await synthesizeText(textChunks[currentChunkIdx], selectedVoiceId);
        
        if (audioContent) {
            audio.src = "data:audio/mp3;base64," + audioContent;
            audio.playbackRate = playbackSpeed;
            audio.play();
            isPlaying = true;
            updateUI();
        }
    }

    audio.onended = function() {
        currentChunkIdx++;
        playNextChunk();
    };
    
    audio.onerror = function() {
        showToast('Playback error', 'error');
        isPlaying = false;
        updateUI();
    };

    function stopAudio() {
        audio.pause();
        audio.currentTime = 0;
        isPlaying = false;
        textChunks = [];
        currentChunkIdx = 0;
        updateUI();
    }

    function togglePlay() {
        if (currentTrackIndex === -1) {
            if (playlist.length > 0) play(0);
            return;
        }
        
        if (audio.paused && audio.src) {
            audio.play();
            isPlaying = true;
        } else if (!audio.paused) {
            audio.pause();
            isPlaying = false;
        } else {
            play(currentTrackIndex);
        }
        updateUI();
    }

    function updateUI() {
        playIcon.style.display = isPlaying ? 'none' : 'block';
        pauseIcon.style.display = isPlaying ? 'block' : 'none';
        renderPlaylist();
    }

    function prevTrack() { 
        stopAudio();
        if (currentTrackIndex > 0) play(currentTrackIndex - 1); 
    }
    
    function nextTrack() { 
        stopAudio();
        if (currentTrackIndex < playlist.length - 1) play(currentTrackIndex + 1); 
    }
    
    function cycleSpeed() {
        var idx = speeds.indexOf(playbackSpeed);
        playbackSpeed = speeds[(idx + 1) % speeds.length];
        speedBtn.textContent = playbackSpeed + 'x';
        if (!audio.paused) audio.playbackRate = playbackSpeed;
    }

    function esc(s) { var d = document.createElement('div'); d.textContent = s; return d.innerHTML; }
    function showToast(msg, type) { toast.textContent = msg; toast.className = 'toast ' + (type || '') + ' show'; setTimeout(function() { toast.classList.remove('show'); }, 3000); }

    function setupEvents() {
        authBtn.onclick = signIn;
        refreshBtn.onclick = syncDrive;
        playPauseBtn.onclick = togglePlay;
        document.getElementById('prev-btn').onclick = prevTrack;
        document.getElementById('next-btn').onclick = nextTrack;
        document.getElementById('rewind-btn').onclick = function() { audio.currentTime -= 10; }; 
        document.getElementById('forward-btn').onclick = function() { audio.currentTime += 10; }; 
        speedBtn.onclick = cycleSpeed;
        
        settingsBtn.onclick = function() { settingsModal.classList.add('visible'); };
        closeSettingsBtn.onclick = function() { settingsModal.classList.remove('visible'); };
        settingsModal.onclick = function(e) { if(e.target === settingsModal) settingsModal.classList.remove('visible'); };
        
        clearAllBtn.onclick = clearAllDocuments;
    }

    init();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Textify">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%230a0a0a' width='100' height='100' rx='20'/><text x='50' y='68' font-size='50' text-anchor='middle' fill='%23e8ff47'>T</text></svg>">
    <title>Textify</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=DM+Sans:opsz,wght@9..40,300;9..40,400;9..40,500;9..40,600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0a0a0a;
            --surface: #141414;
            --surface-hover: #1a1a1a;
            --border: #2a2a2a;
            --text: #fafafa;
            --text-muted: #888;
            --text-dim: #555;
            --accent: #e8ff47;
            --accent-dim: #b8cc39;
            --accent-bg: rgba(232, 255, 71, 0.1);
            --success: #4ade80;
            --error: #f87171;
            --warning: #fbbf24;
            --serif: 'Instrument Serif', Georgia, serif;
            --sans: 'DM Sans', system-ui, sans-serif;
            --radius: 12px;
            --radius-sm: 8px;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        html, body { font-family: var(--sans); background: var(--bg); color: var(--text); min-height: 100vh; min-height: -webkit-fill-available; line-height: 1.6; overflow-x: hidden; }
        .app { display: flex; flex-direction: column; min-height: 100vh; min-height: -webkit-fill-available; }
        .header { padding: 20px 24px; display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid var(--border); position: sticky; top: 0; background: var(--bg); z-index: 100; }
        .logo { font-family: var(--serif); font-size: 1.75rem; font-style: italic; letter-spacing: -0.02em; }
        .logo span { color: var(--accent); }
        .header-actions { display: flex; align-items: center; gap: 12px; }
        .sync-status { display: flex; align-items: center; gap: 6px; font-size: 0.8rem; color: var(--text-muted); }
        .sync-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--text-dim); }
        .sync-dot.syncing { background: var(--warning); animation: pulse 1s infinite; }
        .sync-dot.synced { background: var(--success); }
        .sync-dot.error { background: var(--error); }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .icon-btn { width: 40px; height: 40px; border-radius: var(--radius-sm); border: 1px solid var(--border); background: var(--surface); color: var(--text); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; }
        .icon-btn:hover { background: var(--surface-hover); border-color: #444; }
        .icon-btn.spinning svg { animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .icon-btn svg { width: 20px; height: 20px; }
        .main { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
        .auth-screen { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 40px 24px; text-align: center; }
        .auth-screen.hidden { display: none; }
        .auth-icon { width: 80px; height: 80px; margin-bottom: 24px; color: var(--accent); }
        .auth-title { font-family: var(--serif); font-size: 1.75rem; font-style: italic; margin-bottom: 12px; }
        .auth-desc { color: var(--text-muted); font-size: 0.95rem; max-width: 320px; margin-bottom: 32px; }
        .auth-btn { display: flex; align-items: center; gap: 12px; padding: 16px 32px; background: var(--text); color: var(--bg); border: none; border-radius: var(--radius); font-family: var(--sans); font-size: 1rem; font-weight: 500; cursor: pointer; transition: all 0.2s; }
        .auth-btn:hover { transform: translateY(-2px); box-shadow: 0 8px 24px rgba(0,0,0,0.3); }
        .auth-btn svg { width: 24px; height: 24px; }
        .content { flex: 1; display: none; flex-direction: column; overflow: hidden; }
        .content.visible { display: flex; }
        .playlist-container { flex: 1; overflow-y: auto; padding: 20px 24px; padding-bottom: 220px; }
        .playlist-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; }
        .playlist-title { font-family: var(--serif); font-size: 1.25rem; font-style: italic; }
        .playlist-count { font-size: 0.85rem; color: var(--text-muted); }
        .playlist-empty { text-align: center; padding: 60px 20px; color: var(--text-muted); }
        .playlist { display: flex; flex-direction: column; gap: 8px; }
        .track { display: flex; align-items: center; gap: 16px; padding: 16px; background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius); cursor: pointer; transition: all 0.2s; }
        .track:hover { background: var(--surface-hover); border-color: #444; }
        .track.active { background: var(--accent-bg); border-color: var(--accent); }
        .track.generating { opacity: 0.7; }
        .track-number { width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-size: 0.85rem; color: var(--text-muted); flex-shrink: 0; }
        .track.active .track-number { color: var(--accent); }
        .track-equalizer { display: none; gap: 2px; align-items: flex-end; height: 16px; }
        .track.active.playing .track-number span { display: none; }
        .track.active.playing .track-equalizer { display: flex; }
        .eq-bar { width: 3px; background: var(--accent); border-radius: 1px; animation: eq 0.8s ease-in-out infinite; }
        .eq-bar:nth-child(1) { height: 60%; animation-delay: 0s; }
        .eq-bar:nth-child(2) { height: 100%; animation-delay: 0.2s; }
        .eq-bar:nth-child(3) { height: 40%; animation-delay: 0.4s; }
        @keyframes eq { 0%, 100% { transform: scaleY(1); } 50% { transform: scaleY(0.5); } }
        .track-info { flex: 1; min-width: 0; }
        .track-title { font-weight: 500; font-size: 0.95rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 4px; }
        .track-meta { display: flex; align-items: center; gap: 12px; font-size: 0.8rem; color: var(--text-muted); }
        .track-folder { display: flex; align-items: center; gap: 4px; }
        .track-folder svg { width: 14px; height: 14px; }
        .status-badge { padding: 4px 8px; border-radius: 4px; font-size: 0.7rem; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
        .status-badge.cached { background: rgba(74, 222, 128, 0.15); color: var(--success); }
        .status-badge.generating { background: rgba(251, 191, 36, 0.15); color: var(--warning); }
        .status-badge.new { background: rgba(232, 255, 71, 0.15); color: var(--accent); }
        .status-badge.pending { background: rgba(136, 136, 136, 0.15); color: var(--text-muted); }
        .player { position: fixed; bottom: 0; left: 0; right: 0; background: linear-gradient(to top, var(--bg) 80%, transparent); padding: 20px 24px 32px; padding-bottom: max(32px, env(safe-area-inset-bottom)); }
        .player.hidden { display: none; }
        .player-card { background: var(--surface); border: 1px solid var(--border); border-radius: 16px; padding: 20px; box-shadow: 0 -8px 32px rgba(0,0,0,0.4); }
        .player-track-info { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; }
        .player-track-title { flex: 1; font-weight: 500; font-size: 0.95rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .player-track-position { font-size: 0.8rem; color: var(--text-muted); }
        .player-progress { margin-bottom: 16px; }
        .progress-bar { width: 100%; height: 6px; background: var(--border); border-radius: 3px; overflow: hidden; cursor: pointer; }
        .progress-fill { height: 100%; background: var(--accent); border-radius: 3px; width: 0%; transition: width 0.1s linear; }
        .progress-times { display: flex; justify-content: space-between; margin-top: 8px; font-size: 0.75rem; color: var(--text-muted); font-variant-numeric: tabular-nums; }
        .player-controls { display: flex; align-items: center; justify-content: center; gap: 12px; }
        .control-btn { width: 48px; height: 48px; border-radius: 50%; border: none; background: transparent; color: var(--text); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; }
        .control-btn:hover { background: var(--surface-hover); }
        .control-btn svg { width: 24px; height: 24px; }
        .control-btn.play-pause { width: 64px; height: 64px; background: var(--accent); color: var(--bg); }
        .control-btn.play-pause:hover { background: var(--accent-dim); transform: scale(1.05); }
        .control-btn.play-pause svg { width: 28px; height: 28px; }
        .speed-btn { min-width: 48px; padding: 8px 12px; border-radius: 20px; border: 1px solid var(--border); background: var(--surface); color: var(--text); font-family: var(--sans); font-size: 0.8rem; font-weight: 500; cursor: pointer; transition: all 0.2s; }
        .speed-btn:hover { background: var(--surface-hover); border-color: #444; }
        .toast { position: fixed; top: 24px; left: 50%; transform: translateX(-50%) translateY(-100px); padding: 14px 24px; background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius); color: var(--text); font-size: 0.9rem; opacity: 0; transition: all 0.3s ease-out; z-index: 300; max-width: 90%; text-align: center; }
        .toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }
        .toast.error { border-color: var(--error); }
        .toast.success { border-color: var(--success); }
        @media (max-width: 600px) { .header { padding: 16px 20px; } .playlist-container { padding: 16px 20px; padding-bottom: 240px; } .player { padding: 16px 20px 24px; } .player-controls { gap: 8px; } .control-btn { width: 44px; height: 44px; } .control-btn.play-pause { width: 56px; height: 56px; } }
    </style>
</head>
<body>
    <div class="app">
        <header class="header">
            <h1 class="logo">Textify<span>.</span></h1>
            <div class="header-actions">
                <div class="sync-status"><div class="sync-dot" id="sync-dot"></div><span id="sync-text">Offline</span></div>
                <button class="icon-btn" id="refresh-btn" title="Sync"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M23 4v6h-6M1 20v-6h6"/><path d="M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15"/></svg></button>
            </div>
        </header>
        <main class="main">
            <div class="auth-screen" id="auth-screen">
                <svg class="auth-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><path d="M14 2v6h6M16 13H8M16 17H8M10 9H8"/></svg>
                <h2 class="auth-title">Connect Google Drive</h2>
                <p class="auth-desc">Sign in to sync your documents and listen to them as audio.</p>
                <button class="auth-btn" id="auth-btn">
                    <svg viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>
                    Sign in with Google
                </button>
            </div>
            <div class="content" id="content">
                <div class="playlist-container">
                    <div class="playlist-header"><h2 class="playlist-title">Your Documents</h2><span class="playlist-count" id="playlist-count">0 documents</span></div>
                    <div class="playlist-empty" id="playlist-empty"><p>No documents found. Click sync to check your folders.</p></div>
                    <div class="playlist" id="playlist"></div>
                </div>
            </div>
        </main>
        <div class="player hidden" id="player">
            <div class="player-card">
                <div class="player-track-info"><span class="player-track-title" id="player-title">No track selected</span><span class="player-track-position" id="player-position">0 / 0</span></div>
                <div class="player-progress"><div class="progress-bar" id="progress-bar"><div class="progress-fill" id="progress-fill"></div></div><div class="progress-times"><span id="current-time">0:00</span><span id="total-time">0:00</span></div></div>
                <div class="player-controls">
                    <button class="control-btn" id="prev-btn"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/></svg></button>
                    <button class="control-btn" id="rewind-btn"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 4v6h6"/><path d="M3.51 15a9 9 0 102.13-9.36L1 10"/></svg></button>
                    <button class="control-btn play-pause" id="play-pause-btn"><svg viewBox="0 0 24 24" fill="currentColor" id="play-icon"><path d="M8 5v14l11-7z"/></svg><svg viewBox="0 0 24 24" fill="currentColor" id="pause-icon" style="display:none;"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg></button>
                    <button class="control-btn" id="forward-btn"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M23 4v6h-6"/><path d="M20.49 15a9 9 0 11-2.12-9.36L23 10"/></svg></button>
                    <button class="control-btn" id="next-btn"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg></button>
                    <button class="speed-btn" id="speed-btn">1x</button>
                </div>
            </div>
        </div>
    </div>
    <div class="toast" id="toast"></div>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <script>
        const GOOGLE_CLIENT_ID = '959875839996-h7cogpr60gugmqco9f9i5ehkjr0hq569.apps.googleusercontent.com';
        const GOOGLE_API_KEY = 'AIzaSyCQ1_Y6-w_lOzjRUMN2lxRFuZfT4y-9ICg';
        const ALLOWED_USER = 'briandigate';
        const FOLDER_IDS = ['1YEj74qrmNYMZcQ90l_6wlq6c6DDk4YbR','1kc57wQ2rCLI4yKOK7h2pbhS1XMUFGs9y','1kedNH3hNJUh6frA1iN2xoXc5g--FNvZs'];
        const SCOPES = 'https://www.googleapis.com/auth/drive.readonly https://www.googleapis.com/auth/userinfo.email';
        const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';

        let tokenClient, gapiInited = false, gisInited = false, accessToken = null;
        let playlist = [], currentTrackIndex = -1, isPlaying = false, isSpeaking = false;
        let playbackSpeed = 1;
        const speeds = [0.75, 1, 1.25, 1.5, 1.75, 2];
        let lastSyncTime = null, db;
        const DB_NAME = 'TextifyCache', STORE_NAME = 'documents';

        const authScreen = document.getElementById('auth-screen');
        const authBtn = document.getElementById('auth-btn');
        const content = document.getElementById('content');
        const syncDot = document.getElementById('sync-dot');
        const syncText = document.getElementById('sync-text');
        const refreshBtn = document.getElementById('refresh-btn');
        const playlistEl = document.getElementById('playlist');
        const playlistEmpty = document.getElementById('playlist-empty');
        const playlistCount = document.getElementById('playlist-count');
        const player = document.getElementById('player');
        const playerTitle = document.getElementById('player-title');
        const playerPosition = document.getElementById('player-position');
        const progressBar = document.getElementById('progress-bar');
        const progressFill = document.getElementById('progress-fill');
        const currentTimeEl = document.getElementById('current-time');
        const totalTimeEl = document.getElementById('total-time');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const playIcon = document.getElementById('play-icon');
        const pauseIcon = document.getElementById('pause-icon');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const rewindBtn = document.getElementById('rewind-btn');
        const forwardBtn = document.getElementById('forward-btn');
        const speedBtn = document.getElementById('speed-btn');
        const toast = document.getElementById('toast');

        let currentUtterance = null, utteranceProgress = 0;

        async function init() {
            await initDB();
            await loadCachedPlaylist();
            loadLastSyncTime();
            initGoogleAPI();
            setupEventListeners();
            setupMediaSession();
        }

        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 2);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => { db = request.result; resolve(); };
                request.onupgradeneeded = (e) => {
                    const database = e.target.result;
                    if (!database.objectStoreNames.contains(STORE_NAME)) database.createObjectStore(STORE_NAME, { keyPath: 'id' });
                };
            });
        }

        async function cacheDocument(id, text, metadata) {
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE_NAME, 'readwrite');
                tx.objectStore(STORE_NAME).put({ id, text, metadata, cachedAt: Date.now() });
                tx.oncomplete = resolve;
                tx.onerror = () => reject(tx.error);
            });
        }

        async function getCachedDocument(id) {
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE_NAME, 'readonly');
                const request = tx.objectStore(STORE_NAME).get(id);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function getAllCached() {
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE_NAME, 'readonly');
                const request = tx.objectStore(STORE_NAME).getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        function loadLastSyncTime() {
            const saved = localStorage.getItem('textify_last_sync');
            if (saved) lastSyncTime = new Date(saved);
        }

        function saveLastSyncTime() {
            lastSyncTime = new Date();
            localStorage.setItem('textify_last_sync', lastSyncTime.toISOString());
        }

        function initGoogleAPI() {
            gapi.load('client', async () => {
                try {
                    await gapi.client.init({ apiKey: GOOGLE_API_KEY, discoveryDocs: [DISCOVERY_DOC] });
                    gapiInited = true;
                    maybeEnableAuth();
                } catch (e) { console.error('GAPI init error:', e); showToast('Failed to load Google API', 'error'); }
            });
            tokenClient = google.accounts.oauth2.initTokenClient({ client_id: GOOGLE_CLIENT_ID, scope: SCOPES, callback: handleAuthCallback });
            gisInited = true;
            maybeEnableAuth();
        }

        function maybeEnableAuth() {
            if (gapiInited && gisInited) {
                const storedToken = localStorage.getItem('textify_access_token');
                if (storedToken) {
                    accessToken = storedToken;
                    gapi.client.setToken({ access_token: storedToken });
                    verifyAndShowAuth();
                }
            }
        }

        async function verifyAndShowAuth() {
            try {
                const userInfo = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', { headers: { 'Authorization': `Bearer ${accessToken}` } });
                if (!userInfo.ok) { localStorage.removeItem('textify_access_token'); accessToken = null; return; }
                const user = await userInfo.json();
                const username = user.email.split('@')[0];
                if (username.toLowerCase() !== ALLOWED_USER.toLowerCase()) { showToast('Access denied', 'error'); signOut(); return; }
                showAuthenticatedState();
                syncWithDrive();
            } catch (e) { console.error('Auth verification failed:', e); localStorage.removeItem('textify_access_token'); accessToken = null; }
        }

        async function handleAuthCallback(resp) {
            if (resp.error) { console.error('Auth error:', resp); showToast('Authentication failed', 'error'); return; }
            try {
                const userInfo = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', { headers: { 'Authorization': `Bearer ${resp.access_token}` } });
                const user = await userInfo.json();
                const username = user.email.split('@')[0];
                if (username.toLowerCase() !== ALLOWED_USER.toLowerCase()) { showToast('Access denied. This app is private.', 'error'); google.accounts.oauth2.revoke(resp.access_token); return; }
                accessToken = resp.access_token;
                localStorage.setItem('textify_access_token', accessToken);
                showAuthenticatedState();
                syncWithDrive();
            } catch (e) { console.error('User verification failed:', e); showToast('Could not verify user', 'error'); }
        }

        function signIn() {
            if (!gisInited || !gapiInited) { showToast('Google API not loaded yet', 'error'); return; }
            tokenClient.requestAccessToken({ prompt: 'consent' });
        }

        function signOut() {
            if (accessToken) google.accounts.oauth2.revoke(accessToken);
            accessToken = null;
            localStorage.removeItem('textify_access_token');
            authScreen.classList.remove('hidden');
            content.classList.remove('visible');
            player.classList.add('hidden');
            updateSyncStatus('offline');
        }

        function showAuthenticatedState() {
            authScreen.classList.add('hidden');
            content.classList.add('visible');
            if (playlist.length > 0) player.classList.remove('hidden');
        }

        async function syncWithDrive() {
            if (!accessToken) { updateSyncStatus('error', 'Not signed in'); return; }
            updateSyncStatus('syncing');
            refreshBtn.classList.add('spinning');
            try {
                const files = [];
                for (const folderId of FOLDER_IDS) {
                    try {
                        const folderInfo = await gapi.client.drive.files.get({ fileId: folderId, fields: 'name' });
                        const folderName = folderInfo.result.name;
                        const response = await gapi.client.drive.files.list({
                            q: `'${folderId}' in parents and mimeType='application/vnd.google-apps.document' and trashed=false`,
                            fields: 'files(id, name, modifiedTime)',
                            orderBy: 'modifiedTime desc',
                            pageSize: 100
                        });
                        for (const file of response.result.files || []) {
                            files.push({ id: file.id, name: file.name, folder: folderName, modifiedTime: file.modifiedTime });
                        }
                    } catch (e) { console.error(`Error fetching folder ${folderId}:`, e); }
                }
                const cachedDocs = await getAllCached();
                const cachedIds = new Map(cachedDocs.map(c => [c.id, c]));
                playlist = files.map(file => {
                    const cached = cachedIds.get(file.id);
                    const isNew = lastSyncTime && new Date(file.modifiedTime) > lastSyncTime;
                    const isCached = cached && cached.text;
                    return { ...file, status: isCached ? 'cached' : (isNew ? 'new' : 'pending'), text: cached?.text || null };
                });
                savePlaylistToStorage();
                renderPlaylist();
                const newCount = playlist.filter(t => t.status === 'new').length;
                updateSyncStatus('synced', `${playlist.length} docs${newCount > 0 ? `, ${newCount} new` : ''}`);
                saveLastSyncTime();
                await downloadNewDocuments();
            } catch (error) { console.error('Sync error:', error); updateSyncStatus('error', 'Sync failed'); showToast('Failed to sync with Drive', 'error'); }
            finally { refreshBtn.classList.remove('spinning'); }
        }

        async function downloadNewDocuments() {
            const pending = playlist.filter(t => t.status === 'new' || t.status === 'pending');
            for (const track of pending) await downloadDocument(track);
        }

        async function downloadDocument(track) {
            const index = playlist.findIndex(t => t.id === track.id);
            if (index === -1) return;
            playlist[index].status = 'generating';
            renderPlaylist();
            try {
                const response = await gapi.client.drive.files.export({ fileId: track.id, mimeType: 'text/plain' });
                const text = response.body;
                if (!text || text.trim().length === 0) throw new Error('Empty document');
                await cacheDocument(track.id, text, { name: track.name, folder: track.folder });
                playlist[index].status = 'cached';
                playlist[index].text = text;
                savePlaylistToStorage();
                renderPlaylist();
            } catch (error) { console.error('Download error:', error); playlist[index].status = 'pending'; renderPlaylist(); }
        }

        function savePlaylistToStorage() {
            const toSave = playlist.map(({ text, ...rest }) => rest);
            localStorage.setItem('textify_playlist', JSON.stringify(toSave));
        }

        async function loadCachedPlaylist() {
            const saved = localStorage.getItem('textify_playlist');
            if (saved) {
                playlist = JSON.parse(saved);
                const cached = await getAllCached();
                const cachedMap = new Map(cached.map(c => [c.id, c]));
                playlist.forEach(track => { const doc = cachedMap.get(track.id); if (doc) { track.text = doc.text; track.status = 'cached'; } });
                renderPlaylist();
            }
        }

        function renderPlaylist() {
            if (playlist.length === 0) { playlistEmpty.style.display = 'block'; playlistEl.innerHTML = ''; playlistCount.textContent = '0 documents'; return; }
            playlistEmpty.style.display = 'none';
            playlistCount.textContent = `${playlist.length} document${playlist.length !== 1 ? 's' : ''}`;
            playlistEl.innerHTML = playlist.map((track, index) => `
                <div class="track ${index === currentTrackIndex ? 'active' : ''} ${isPlaying && index === currentTrackIndex ? 'playing' : ''} ${track.status === 'generating' ? 'generating' : ''}" data-index="${index}">
                    <div class="track-number"><span>${index + 1}</span><div class="track-equalizer"><div class="eq-bar"></div><div class="eq-bar"></div><div class="eq-bar"></div></div></div>
                    <div class="track-info">
                        <div class="track-title">${escapeHtml(track.name)}</div>
                        <div class="track-meta"><span class="track-folder"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>${escapeHtml(track.folder)}</span><span class="status-badge ${track.status}">${track.status}</span></div>
                    </div>
                </div>
            `).join('');
            document.querySelectorAll('.track').forEach(el => { el.addEventListener('click', () => playTrack(parseInt(el.dataset.index))); });
            if (playlist.length > 0) player.classList.remove('hidden');
        }

        async function playTrack(index) {
            if (index < 0 || index >= playlist.length) return;
            const track = playlist[index];
            if (!track.text) {
                showToast('Downloading document...', 'info');
                await downloadDocument(track);
                if (!playlist[index].text) { showToast('Could not load document', 'error'); return; }
            }
            stopSpeech();
            currentTrackIndex = index;
            const text = playlist[index].text;
            currentUtterance = new SpeechSynthesisUtterance(text);
            currentUtterance.rate = playbackSpeed;
            const voices = speechSynthesis.getVoices();
            const preferredVoice = voices.find(v => v.lang.startsWith('en') && (v.name.includes('Samantha') || v.name.includes('Google') || v.name.includes('Natural'))) || voices.find(v => v.lang.startsWith('en'));
            if (preferredVoice) currentUtterance.voice = preferredVoice;
            utteranceProgress = 0;
            currentUtterance.onstart = () => { isPlaying = true; isSpeaking = true; updatePlayButton(); renderPlaylist(); updateMediaSession(); startProgressTimer(); };
            currentUtterance.onend = () => { isSpeaking = false; stopProgressTimer(); if (currentTrackIndex < playlist.length - 1) { playTrack(currentTrackIndex + 1); } else { isPlaying = false; updatePlayButton(); renderPlaylist(); } };
            currentUtterance.onerror = (e) => { console.error('Speech error:', e); isPlaying = false; isSpeaking = false; updatePlayButton(); renderPlaylist(); stopProgressTimer(); };
            currentUtterance.onboundary = (e) => { if (e.name === 'word') { utteranceProgress = e.charIndex / text.length; updateProgressDisplay(); } };
            playerTitle.textContent = track.name;
            playerPosition.textContent = `${index + 1} / ${playlist.length}`;
            const wordCount = text.split(/\s+/).length;
            const estimatedSeconds = (wordCount / 150) * 60 / playbackSpeed;
            totalTimeEl.textContent = formatTime(estimatedSeconds);
            speechSynthesis.speak(currentUtterance);
        }

        let progressTimer = null;
        function startProgressTimer() { stopProgressTimer(); progressTimer = setInterval(updateProgressDisplay, 100); }
        function stopProgressTimer() { if (progressTimer) { clearInterval(progressTimer); progressTimer = null; } }

        function updateProgressDisplay() {
            progressFill.style.width = `${utteranceProgress * 100}%`;
            if (currentTrackIndex >= 0 && playlist[currentTrackIndex]?.text) {
                const text = playlist[currentTrackIndex].text;
                const wordCount = text.split(/\s+/).length;
                const totalSeconds = (wordCount / 150) * 60 / playbackSpeed;
                const currentSeconds = utteranceProgress * totalSeconds;
                currentTimeEl.textContent = formatTime(currentSeconds);
            }
        }

        function stopSpeech() { speechSynthesis.cancel(); isSpeaking = false; isPlaying = false; stopProgressTimer(); }

        function togglePlayPause() {
            if (!isSpeaking && currentTrackIndex === -1) { if (playlist.length > 0) playTrack(0); return; }
            if (isSpeaking) { if (speechSynthesis.paused) { speechSynthesis.resume(); isPlaying = true; } else { speechSynthesis.pause(); isPlaying = false; } }
            else { playTrack(currentTrackIndex >= 0 ? currentTrackIndex : 0); }
            updatePlayButton(); renderPlaylist();
        }

        function updatePlayButton() { playIcon.style.display = isPlaying ? 'none' : 'block'; pauseIcon.style.display = isPlaying ? 'block' : 'none'; }
        function prevTrack() { if (currentTrackIndex > 0) playTrack(currentTrackIndex - 1); }
        function nextTrack() { if (currentTrackIndex < playlist.length - 1) playTrack(currentTrackIndex + 1); }
        function rewind() { if (currentTrackIndex >= 0) playTrack(currentTrackIndex); }
        function forward() { nextTrack(); }
        function cycleSpeed() { const currentIndex = speeds.indexOf(playbackSpeed); playbackSpeed = speeds[(currentIndex + 1) % speeds.length]; speedBtn.textContent = `${playbackSpeed}x`; if (isSpeaking && currentTrackIndex >= 0) playTrack(currentTrackIndex); }

        function setupMediaSession() {
            if ('mediaSession' in navigator) {
                navigator.mediaSession.setActionHandler('play', togglePlayPause);
                navigator.mediaSession.setActionHandler('pause', togglePlayPause);
                navigator.mediaSession.setActionHandler('previoustrack', prevTrack);
                navigator.mediaSession.setActionHandler('nexttrack', nextTrack);
            }
        }

        function updateMediaSession() {
            if ('mediaSession' in navigator && currentTrackIndex >= 0) {
                const track = playlist[currentTrackIndex];
                navigator.mediaSession.metadata = new MediaMetadata({ title: track.name, artist: 'Textify', album: track.folder });
            }
        }

        function formatTime(seconds) { if (!seconds || isNaN(seconds)) return '0:00'; const mins = Math.floor(seconds / 60); const secs = Math.floor(seconds % 60); return `${mins}:${secs.toString().padStart(2, '0')}`; }
        function escapeHtml(text) { const div = document.createElement('div'); div.textContent = text; return div.innerHTML; }
        function updateSyncStatus(status, text = '') { syncDot.className = 'sync-dot ' + status; syncText.textContent = status === 'syncing' ? 'Syncing...' : (status === 'synced' ? (text || 'Synced') : (status === 'error' ? (text || 'Error') : 'Offline')); }
        function showToast(message, type = 'info') { toast.textContent = message; toast.className = `toast ${type} show`; setTimeout(() => toast.classList.remove('show'), 3000); }

        function setupEventListeners() {
            authBtn.addEventListener('click', signIn);
            refreshBtn.addEventListener('click', syncWithDrive);
            playPauseBtn.addEventListener('click', togglePlayPause);
            prevBtn.addEventListener('click', prevTrack);
            nextBtn.addEventListener('click', nextTrack);
            rewindBtn.addEventListener('click', rewind);
            forwardBtn.addEventListener('click', forward);
            speedBtn.addEventListener('click', cycleSpeed);
            progressBar.addEventListener('click', () => showToast('Seeking not available with browser voices', 'info'));
            speechSynthesis.onvoiceschanged = () => console.log('Voices loaded:', speechSynthesis.getVoices().length);
        }

        init();
    </script>
</body>
</html>